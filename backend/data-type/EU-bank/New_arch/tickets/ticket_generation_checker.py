# EU Banking Ticket Generation Checker
# This script checks which ticket object IDs have been generated data by the LLM
import os
import json
import csv
from datetime import datetime
from pymongo import MongoClient
from bson import ObjectId
from dotenv import load_dotenv
from pathlib import Path
import logging

# Load environment variables
load_dotenv()

# MongoDB setup
MONGO_URI = os.getenv("MONGO_CONNECTION_STRING")
DB_NAME = "sparzaai"
TICKET_COLLECTION = "tickets"

# Logging setup
LOG_DIR = Path("logs")
LOG_DIR.mkdir(exist_ok=True)

# Create timestamped log file
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
LOG_FILE = LOG_DIR / f"ticket_generation_check_{timestamp}.log"

# Configure logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE, encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class TicketGenerationChecker:
    """Check which tickets have been generated by the LLM"""
    
    def __init__(self):
        self.client = None
        self.db = None
        self.ticket_col = None
        self.results = {
            'generated_tickets': [],
            'missing_tickets': [],
            'partial_tickets': [],
            'statistics': {}
        }
    
    def init_database(self):
        """Initialize database connection"""
        try:
            self.client = MongoClient(MONGO_URI, serverSelectionTimeoutMS=5000)
            # Test connection
            self.client.admin.command('ping')
            self.db = self.client[DB_NAME]
            self.ticket_col = self.db[TICKET_COLLECTION]
            logger.info("Database connection established")
            return True
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return False
    
    def check_ticket_generation_status(self):
        """Check which tickets have been generated by the LLM"""
        logger.info("Starting ticket generation status check...")
        
        try:
            # Get all tickets
            all_tickets = list(self.ticket_col.find({}, {"_id": 1}))
            total_tickets = len(all_tickets)
            logger.info(f"Found {total_tickets} total tickets in collection")
            
            # Define criteria for fully generated tickets
            fully_generated_criteria = {
                "messages.0.body.text.plain": {"$exists": True, "$ne": "", "$ne": None},
                "thread.subject_norm": {"$exists": True, "$ne": "", "$ne": None},
                "priority": {"$exists": True, "$ne": "", "$ne": None},
                "urgency": {"$exists": True, "$ne": "", "$ne": None},
                "stages": {"$exists": True, "$ne": "", "$ne": None},
                "ticket_summary": {"$exists": True, "$ne": "", "$ne": None},
                "resolution_status": {"$exists": True, "$ne": "", "$ne": None},
                "overall_sentiment": {"$exists": True, "$ne": "", "$ne": None},
                "ticket_raised": {"$exists": True, "$ne": "", "$ne": None},
                "ticket_source": {"$exists": True, "$ne": "", "$ne": None},
                "assigned_team": {"$exists": True, "$ne": "", "$ne": None}
            }
            
            # Find fully generated tickets
            fully_generated = list(self.ticket_col.find(fully_generated_criteria, {"_id": 1}))
            fully_generated_ids = [str(ticket['_id']) for ticket in fully_generated]
            
            # Find tickets with some generated content (partial)
            partial_criteria = {
                "$or": [
                    {"messages.0.body.text.plain": {"$exists": True, "$ne": "", "$ne": None}},
                    {"thread.subject_norm": {"$exists": True, "$ne": "", "$ne": None}},
                    {"priority": {"$exists": True, "$ne": "", "$ne": None}},
                    {"urgency": {"$exists": True, "$ne": "", "$ne": None}},
                    {"stages": {"$exists": True, "$ne": "", "$ne": None}},
                    {"ticket_summary": {"$exists": True, "$ne": "", "$ne": None}},
                    {"resolution_status": {"$exists": True, "$ne": "", "$ne": None}},
                    {"overall_sentiment": {"$exists": True, "$ne": "", "$ne": None}},
                    {"ticket_raised": {"$exists": True, "$ne": "", "$ne": None}},
                    {"ticket_source": {"$exists": True, "$ne": "", "$ne": None}},
                    {"assigned_team": {"$exists": True, "$ne": "", "$ne": None}}
                ]
            }
            
            partial_tickets = list(self.ticket_col.find(partial_criteria, {"_id": 1}))
            partial_ids = [str(ticket['_id']) for ticket in partial_tickets]
            
            # Find tickets with no generated content
            no_content_criteria = {
                "$and": [
                    {"messages.0.body.text.plain": {"$in": [None, ""]}},
                    {"thread.subject_norm": {"$in": [None, ""]}},
                    {"priority": {"$exists": False}},
                    {"urgency": {"$exists": False}},
                    {"stages": {"$exists": False}},
                    {"ticket_summary": {"$exists": False}},
                    {"resolution_status": {"$exists": False}},
                    {"overall_sentiment": {"$exists": False}},
                    {"ticket_raised": {"$exists": False}},
                    {"ticket_source": {"$exists": False}},
                    {"assigned_team": {"$exists": False}}
                ]
            }
            
            missing_tickets = list(self.ticket_col.find(no_content_criteria, {"_id": 1}))
            missing_ids = [str(ticket['_id']) for ticket in missing_tickets]
            
            # Store results
            self.results['generated_tickets'] = fully_generated_ids
            self.results['missing_tickets'] = missing_ids
            self.results['partial_tickets'] = list(set(partial_ids) - set(fully_generated_ids))
            
            # Calculate statistics
            self.results['statistics'] = {
                'total_tickets': total_tickets,
                'fully_generated': len(fully_generated_ids),
                'partially_generated': len(self.results['partial_tickets']),
                'missing_content': len(missing_ids),
                'completion_percentage': (len(fully_generated_ids) / total_tickets * 100) if total_tickets > 0 else 0,
                'partial_percentage': (len(self.results['partial_tickets']) / total_tickets * 100) if total_tickets > 0 else 0,
                'missing_percentage': (len(missing_ids) / total_tickets * 100) if total_tickets > 0 else 0
            }
            
            logger.info(f"Analysis complete:")
            logger.info(f"  Total tickets: {total_tickets}")
            logger.info(f"  Fully generated: {len(fully_generated_ids)} ({self.results['statistics']['completion_percentage']:.1f}%)")
            logger.info(f"  Partially generated: {len(self.results['partial_tickets'])} ({self.results['statistics']['partial_percentage']:.1f}%)")
            logger.info(f"  Missing content: {len(missing_ids)} ({self.results['statistics']['missing_percentage']:.1f}%)")
            
            return True
            
        except Exception as e:
            logger.error(f"Error checking ticket generation status: {e}")
            return False
    
    def get_detailed_analysis(self, limit=10):
        """Get detailed analysis of ticket generation status"""
        logger.info("Getting detailed analysis...")
        
        try:
            # Analyze fully generated tickets
            fully_generated_details = list(self.ticket_col.find({
                "messages.0.body.text.plain": {"$exists": True, "$ne": "", "$ne": None},
                "thread.subject_norm": {"$exists": True, "$ne": "", "$ne": None},
                "priority": {"$exists": True, "$ne": "", "$ne": None},
                "stages": {"$exists": True, "$ne": "", "$ne": None}
            }).limit(limit))
            
            # Analyze missing tickets
            missing_details = list(self.ticket_col.find({
                "$and": [
                    {"messages.0.body.text.plain": {"$in": [None, ""]}},
                    {"priority": {"$exists": False}}
                ]
            }).limit(limit))
            
            # Analyze partial tickets
            partial_details = list(self.ticket_col.find({
                "$and": [
                    {"$or": [
                        {"messages.0.body.text.plain": {"$exists": True, "$ne": "", "$ne": None}},
                        {"priority": {"$exists": True, "$ne": "", "$ne": None}},
                        {"stages": {"$exists": True, "$ne": "", "$ne": None}}
                    ]},
                    {"$or": [
                        {"messages.0.body.text.plain": {"$in": [None, ""]}},
                        {"priority": {"$exists": False}},
                        {"stages": {"$exists": False}}
                    ]}
                ]
            }).limit(limit))
            
            detailed_analysis = {
                'fully_generated_sample': [],
                'missing_sample': [],
                'partial_sample': []
            }
            
            # Process fully generated tickets
            for ticket in fully_generated_details:
                detailed_analysis['fully_generated_sample'].append({
                    'ticket_id': str(ticket['_id']),
                    'dominant_topic': ticket.get('dominant_topic', 'N/A'),
                    'ticket_title': ticket.get('thread', {}).get('subject_norm', 'N/A'),
                    'priority': ticket.get('priority', 'N/A'),
                    'urgency': ticket.get('urgency', 'N/A'),
                    'stages': ticket.get('stages', 'N/A'),
                    'assigned_team': ticket.get('assigned_team', 'N/A'),
                    'ticket_source': ticket.get('ticket_source', 'N/A'),
                    'message_count': len(ticket.get('messages', [])),
                    'ticket_raised': ticket.get('ticket_raised', 'N/A'),
                    'overall_sentiment': ticket.get('overall_sentiment', 'N/A')
                })
            
            # Process missing tickets
            for ticket in missing_details:
                detailed_analysis['missing_sample'].append({
                    'ticket_id': str(ticket['_id']),
                    'dominant_topic': ticket.get('dominant_topic', 'N/A'),
                    'subtopics': ticket.get('subtopics', 'N/A')[:100] + '...' if len(str(ticket.get('subtopics', ''))) > 100 else ticket.get('subtopics', 'N/A'),
                    'has_messages': len(ticket.get('messages', [])) > 0,
                    'has_thread': bool(ticket.get('thread', {})),
                    'missing_fields': self._get_missing_fields(ticket)
                })
            
            # Process partial tickets
            for ticket in partial_details:
                detailed_analysis['partial_sample'].append({
                    'ticket_id': str(ticket['_id']),
                    'dominant_topic': ticket.get('dominant_topic', 'N/A'),
                    'has_messages': bool(ticket.get('messages', [{}])[0].get('body', {}).get('text', {}).get('plain')),
                    'has_priority': bool(ticket.get('priority')),
                    'has_stages': bool(ticket.get('stages')),
                    'has_assigned_team': bool(ticket.get('assigned_team')),
                    'present_fields': self._get_present_fields(ticket),
                    'missing_fields': self._get_missing_fields(ticket)
                })
            
            return detailed_analysis
            
        except Exception as e:
            logger.error(f"Error getting detailed analysis: {e}")
            return {}
    
    def _get_missing_fields(self, ticket):
        """Get list of missing required fields"""
        required_fields = [
            'messages.0.body.text.plain',
            'thread.subject_norm', 
            'priority',
            'urgency',
            'stages',
            'ticket_summary',
            'resolution_status',
            'overall_sentiment',
            'ticket_raised',
            'ticket_source',
            'assigned_team'
        ]
        
        missing = []
        for field in required_fields:
            if '.' in field:
                # Handle nested fields
                parts = field.split('.')
                current = ticket
                try:
                    for part in parts:
                        current = current[part]
                    if not current or current == "":
                        missing.append(field)
                except (KeyError, TypeError):
                    missing.append(field)
            else:
                if field not in ticket or not ticket[field] or ticket[field] == "":
                    missing.append(field)
        
        return missing
    
    def _get_present_fields(self, ticket):
        """Get list of present required fields"""
        required_fields = [
            'messages.0.body.text.plain',
            'thread.subject_norm', 
            'priority',
            'urgency',
            'stages',
            'ticket_summary',
            'resolution_status',
            'overall_sentiment',
            'ticket_raised',
            'ticket_source',
            'assigned_team'
        ]
        
        present = []
        for field in required_fields:
            if '.' in field:
                # Handle nested fields
                parts = field.split('.')
                current = ticket
                try:
                    for part in parts:
                        current = current[part]
                    if current and current != "":
                        present.append(field)
                except (KeyError, TypeError):
                    pass
            else:
                if field in ticket and ticket[field] and ticket[field] != "":
                    present.append(field)
        
        return present
    
    def export_results_to_csv(self, filename=None):
        """Export results to CSV files"""
        if not filename:
            filename = f"ticket_generation_report_{timestamp}"
        
        try:
            # Export fully generated tickets
            generated_file = f"{filename}_generated.csv"
            with open(generated_file, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['Ticket ID', 'Status'])
                for ticket_id in self.results['generated_tickets']:
                    writer.writerow([ticket_id, 'Fully Generated'])
            logger.info(f"Exported {len(self.results['generated_tickets'])} generated tickets to {generated_file}")
            
            # Export missing tickets
            missing_file = f"{filename}_missing.csv"
            with open(missing_file, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['Ticket ID', 'Status'])
                for ticket_id in self.results['missing_tickets']:
                    writer.writerow([ticket_id, 'Missing Content'])
            logger.info(f"Exported {len(self.results['missing_tickets'])} missing tickets to {missing_file}")
            
            # Export partial tickets
            partial_file = f"{filename}_partial.csv"
            with open(partial_file, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['Ticket ID', 'Status'])
                for ticket_id in self.results['partial_tickets']:
                    writer.writerow([ticket_id, 'Partially Generated'])
            logger.info(f"Exported {len(self.results['partial_tickets'])} partial tickets to {partial_file}")
            
            # Export statistics
            stats_file = f"{filename}_statistics.csv"
            with open(stats_file, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['Metric', 'Count', 'Percentage'])
                stats = self.results['statistics']
                writer.writerow(['Total Tickets', stats['total_tickets'], '100.0%'])
                writer.writerow(['Fully Generated', stats['fully_generated'], f"{stats['completion_percentage']:.1f}%"])
                writer.writerow(['Partially Generated', stats['partially_generated'], f"{stats['partial_percentage']:.1f}%"])
                writer.writerow(['Missing Content', stats['missing_content'], f"{stats['missing_percentage']:.1f}%"])
            logger.info(f"Exported statistics to {stats_file}")
            
            return {
                'generated_file': generated_file,
                'missing_file': missing_file,
                'partial_file': partial_file,
                'stats_file': stats_file
            }
            
        except Exception as e:
            logger.error(f"Error exporting to CSV: {e}")
            return {}
    
    def export_results_to_json(self, filename=None):
        """Export results to JSON file"""
        if not filename:
            filename = f"ticket_generation_report_{timestamp}.json"
        
        try:
            # Add timestamp to results
            export_data = {
                'check_timestamp': datetime.now().isoformat(),
                'database': DB_NAME,
                'collection': TICKET_COLLECTION,
                'results': self.results
            }
            
            with open(filename, 'w', encoding='utf-8') as jsonfile:
                json.dump(export_data, jsonfile, indent=2)
            
            logger.info(f"Exported complete results to {filename}")
            return filename
            
        except Exception as e:
            logger.error(f"Error exporting to JSON: {e}")
            return None
    
    def print_summary_report(self):
        """Print a comprehensive summary report"""
        logger.info("=" * 80)
        logger.info("TICKET GENERATION STATUS REPORT")
        logger.info("=" * 80)
        
        stats = self.results['statistics']
        
        logger.info(f"Database: {DB_NAME}")
        logger.info(f"Collection: {TICKET_COLLECTION}")
        logger.info(f"Check Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info("")
        
        logger.info("OVERALL STATISTICS:")
        logger.info(f"  Total Tickets: {stats['total_tickets']}")
        logger.info(f"  Fully Generated: {stats['fully_generated']} ({stats['completion_percentage']:.1f}%)")
        logger.info(f"  Partially Generated: {stats['partially_generated']} ({stats['partial_percentage']:.1f}%)")
        logger.info(f"  Missing Content: {stats['missing_content']} ({stats['missing_percentage']:.1f}%)")
        logger.info("")
        
        logger.info("COMPLETION STATUS:")
        if stats['completion_percentage'] >= 90:
            logger.info("  [EXCELLENT] Over 90% completion")
        elif stats['completion_percentage'] >= 75:
            logger.info("  [GOOD] Over 75% completion")
        elif stats['completion_percentage'] >= 50:
            logger.info("  [MODERATE] Over 50% completion")
        else:
            logger.info("  [LOW] Under 50% completion")
        
        logger.info("")
        logger.info(f"Generated Tickets: {len(self.results['generated_tickets'])}")
        logger.info(f"Missing Tickets: {len(self.results['missing_tickets'])}")
        logger.info(f"Partial Tickets: {len(self.results['partial_tickets'])}")
        
        # Show sample IDs
        if self.results['generated_tickets']:
            logger.info("")
            logger.info("Sample Generated Ticket IDs:")
            for i, ticket_id in enumerate(self.results['generated_tickets'][:5]):
                logger.info(f"  {i+1}. {ticket_id}")
            if len(self.results['generated_tickets']) > 5:
                logger.info(f"  ... and {len(self.results['generated_tickets']) - 5} more")
        
        if self.results['missing_tickets']:
            logger.info("")
            logger.info("Sample Missing Ticket IDs:")
            for i, ticket_id in enumerate(self.results['missing_tickets'][:5]):
                logger.info(f"  {i+1}. {ticket_id}")
            if len(self.results['missing_tickets']) > 5:
                logger.info(f"  ... and {len(self.results['missing_tickets']) - 5} more")
        
        logger.info("=" * 80)
    
    def cleanup(self):
        """Cleanup database connection"""
        if self.client:
            try:
                self.client.close()
                logger.info("Database connection closed")
            except Exception as e:
                logger.error(f"Error closing database connection: {e}")

def main():
    """Main function to run the ticket generation checker"""
    logger.info("EU Banking Ticket Generation Checker Starting...")
    
    checker = TicketGenerationChecker()
    
    try:
        # Initialize database
        if not checker.init_database():
            logger.error("Cannot proceed without database connection")
            return
        
        # Check ticket generation status
        if not checker.check_ticket_generation_status():
            logger.error("Failed to check ticket generation status")
            return
        
        # Get detailed analysis
        detailed_analysis = checker.get_detailed_analysis(limit=5)
        
        # Print summary report
        checker.print_summary_report()
        
        # Export results
        logger.info("Exporting results...")
        csv_files = checker.export_results_to_csv()
        json_file = checker.export_results_to_json()
        
        if csv_files:
            logger.info("CSV files exported:")
            for file_type, filename in csv_files.items():
                logger.info(f"  {file_type}: {filename}")
        
        if json_file:
            logger.info(f"JSON file exported: {json_file}")
        
        # Show detailed analysis
        if detailed_analysis:
            logger.info("")
            logger.info("DETAILED ANALYSIS:")
            logger.info("=" * 50)
            
            if detailed_analysis['fully_generated_sample']:
                logger.info("Sample Fully Generated Tickets:")
                for i, ticket in enumerate(detailed_analysis['fully_generated_sample'][:3], 1):
                    logger.info(f"  {i}. ID: {ticket['ticket_id']}")
                    logger.info(f"     Topic: {ticket['dominant_topic']}")
                    logger.info(f"     Title: {ticket['ticket_title']}")
                    logger.info(f"     Priority: {ticket['priority']}, Stage: {ticket['stages']}")
                    logger.info(f"     Team: {ticket['assigned_team']}")
                    logger.info("")
            
            if detailed_analysis['missing_sample']:
                logger.info("Sample Missing Tickets:")
                for i, ticket in enumerate(detailed_analysis['missing_sample'][:3], 1):
                    logger.info(f"  {i}. ID: {ticket['ticket_id']}")
                    logger.info(f"     Topic: {ticket['dominant_topic']}")
                    logger.info(f"     Missing Fields: {', '.join(ticket['missing_fields'][:5])}")
                    if len(ticket['missing_fields']) > 5:
                        logger.info(f"     ... and {len(ticket['missing_fields']) - 5} more")
                    logger.info("")
            
            if detailed_analysis['partial_sample']:
                logger.info("Sample Partial Tickets:")
                for i, ticket in enumerate(detailed_analysis['partial_sample'][:3], 1):
                    logger.info(f"  {i}. ID: {ticket['ticket_id']}")
                    logger.info(f"     Topic: {ticket['dominant_topic']}")
                    logger.info(f"     Present: {', '.join(ticket['present_fields'][:3])}")
                    logger.info(f"     Missing: {', '.join(ticket['missing_fields'][:3])}")
                    logger.info("")
        
        logger.info("")
        logger.info("Check complete! Check the log file for detailed information:")
        logger.info(f"Log file: {LOG_FILE}")
        
    except Exception as e:
        logger.error(f"Unexpected error in main: {e}")
    finally:
        checker.cleanup()

if __name__ == "__main__":
    main()
